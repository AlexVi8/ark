use std::fs;
use std::path::Path;

pub struct RdFile {
    pub doc_type: Option<RdDocType>,
}

#[derive(Debug, PartialEq)]
pub enum RdDocType {
    Data,
    Package,
}

impl RdFile {
    pub fn load_from_file(path: &Path) -> anyhow::Result<Self> {
        let content = fs::read_to_string(path).map_err(|err| {
            anyhow::anyhow!(
                "Failed to read Rd file '{path}': {err}",
                path = path.to_string_lossy()
            )
        })?;

        let doc_type = parse_doc_type(&content);
        Ok(RdFile { doc_type })
    }
}

fn parse_doc_type(content: &str) -> Option<RdDocType> {
    static RE: std::sync::LazyLock<regex::Regex> =
        std::sync::LazyLock::new(|| regex::Regex::new(r"\\docType\{(data|package)\}").unwrap());

    let captures = RE.captures(content)?;

    match captures.get(1)?.as_str() {
        "data" => Some(RdDocType::Data),
        "package" => Some(RdDocType::Package),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_doc_type_data() {
        let input = r#"\docType{data}"#;
        assert_eq!(parse_doc_type(input), Some(RdDocType::Data));

        let input = r#"
            % Generated by roxygen2: do not edit by hand
            \docType{data}
        "#;
        assert_eq!(parse_doc_type(input), Some(RdDocType::Data));

        let input = r#"
            % Generated by roxygen2: do not edit by hand
            \docType{data}"
            \docType{package}
        "#;
        assert_eq!(parse_doc_type(input), Some(RdDocType::Data));
    }

    #[test]
    fn test_parse_doc_type_package() {
        let input = r#"\docType{package}"#;
        assert_eq!(parse_doc_type(input), Some(RdDocType::Package));
    }

    #[test]
    fn test_parse_doc_type_none() {
        let input = r#"\title{Something}"#;
        assert_eq!(parse_doc_type(input), None);
    }
}
